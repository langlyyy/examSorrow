[
    {
        "index": "1",
        "title": "数组的存储方式有以下两种（）",
        "listData": [
            {
                "index": "A",
                "text": "顺序表和链表"
            },
            {
                "index": "B",
                "text": "堆栈和队列"
            },
            {
                "index": "C",
                "text": "行优先和列优先"
            },
            {
                "index": "D",
                "text": "对称矩阵和三角矩阵"
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "index": "2",
        "title": "广义表的表头是指（）",
        "listData": [
            {
                "index": "A",
                "text": "表中第一个元素"
            },
            {
                "index": "B",
                "text": "表中最后一个元素"
            },
            {
                "index": "C",
                "text": "除表中第一个元素以外，其余元素组成的子表"
            },
            {
                "index": "D",
                "text": "除表中最后一个元素以外，其余元素组成的子表"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "3",
        "title": "广义表的表尾是指（）",
        "listData": [
            {
                "index": "A",
                "text": "表中第一个元素"
            },
            {
                "index": "B",
                "text": "表中最后一个元素"
            },
            {
                "index": "C",
                "text": "除表中第一个元素以外，其余元素组成的子表"
            },
            {
                "index": "D",
                "text": "除表中最后一个元素以外，其余元素组成的子表"
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "index": "4",
        "title": "已知对称矩阵有4行4列，必定与元素a23相等的元素是（）",
        "listData": [
            {
                "index": "A",
                "text": "a32"
            },
            {
                "index": "B",
                "text": "a33"
            },
            {
                "index": "C",
                "text": "a00"
            },
            {
                "index": "D",
                "text": "a22"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "5",
        "title": "已知矩阵A有4行5列，矩阵首元素下标为[0,0]，每个元素使用4个字节，现用一维数组B存储该矩阵，数组B的内存首址为10000，若采用行序为主，矩阵元素A[3, 2]在内存的地址是（）",
        "listData": [
            {
                "index": "A",
                "text": "10052"
            },
            {
                "index": "B",
                "text": "10068"
            },
            {
                "index": "C",
                "text": "10005"
            },
            {
                "index": "D",
                "text": "10020"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "index": "6",
        "title": "以下哪一种是串匹配的常用算法（）",
        "listData": [
            {
                "index": "A",
                "text": "普里姆算法"
            },
            {
                "index": "B",
                "text": "克鲁斯卡尔算法"
            },
            {
                "index": "C",
                "text": "KMP算法"
            },
            {
                "index": "D",
                "text": "关键路径算法"
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "index": "7",
        "title": "已知主串为abcbcaddabc，模式串为cad，假设串位置从1开始，则串匹配位置是（）",
        "listData": [
            {
                "index": "A",
                "text": "3"
            },
            {
                "index": "B",
                "text": "5"
            },
            {
                "index": "C",
                "text": "7"
            },
            {
                "index": "D",
                "text": "不存在"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "index": "8",
        "title": "树的存储结构不包括（）",
        "listData": [
            {
                "index": "A",
                "text": "祖先表示法"
            },
            {
                "index": "B",
                "text": "双亲表示法"
            },
            {
                "index": "C",
                "text": "孩子表示法"
            },
            {
                "index": "D",
                "text": "孩子兄弟表示法"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "9",
        "title": "二叉树的深度为8，则该二叉树最多有（）个结点",
        "listData": [
            {
                "index": "A",
                "text": "15"
            },
            {
                "index": "B",
                "text": "16"
            },
            {
                "index": "C",
                "text": "255"
            },
            {
                "index": "D",
                "text": "256"
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "index": "10",
        "title": "已知二叉树有11个结点，其中4个结点是有一个孩子，叶子有（）个",
        "listData": [
            {
                "index": "A",
                "text": "4"
            },
            {
                "index": "B",
                "text": "5"
            },
            {
                "index": "C",
                "text": "6"
            },
            {
                "index": "D",
                "text": "3"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "11",
        "title": "为了避免重复遍历在二叉树中保存前驱后继信息，这种二叉树称为（）",
        "listData": [
            {
                "index": "A",
                "text": "遍历二叉树"
            },
            {
                "index": "B",
                "text": "完全二叉树"
            },
            {
                "index": "C",
                "text": "满二叉树"
            },
            {
                "index": "D",
                "text": "线索二叉树"
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "index": "12",
        "title": "二叉树的中序遍历序列中，结点P排在结点Q之前的条件是（）",
        "listData": [
            {
                "index": "A",
                "text": "在二叉树中P在Q的左边"
            },
            {
                "index": "B",
                "text": "在二叉树中P在Q的右边"
            },
            {
                "index": "C",
                "text": "在二叉树中P是Q的祖先"
            },
            {
                "index": "D",
                "text": "在二叉树中P是Q的子孙"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "13",
        "title": "以下结构不是存储结构的（）",
        "listData": [
            {
                "index": "A",
                "text": "邻接表"
            },
            {
                "index": "B",
                "text": "逆邻接表"
            },
            {
                "index": "C",
                "text": "邻接矩阵"
            },
            {
                "index": "D",
                "text": "有向无环图"
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "index": "14",
        "title": "图遍历的算法有（）",
        "listData": [
            {
                "index": "A",
                "text": "中序遍历"
            },
            {
                "index": "B",
                "text": "普里姆"
            },
            {
                "index": "C",
                "text": "佛洛依德"
            },
            {
                "index": "D",
                "text": "广度优先搜索"
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "index": "15",
        "title": "已知有向图G=(V,E)，其中V={1,2,3,4,5,6,}， E={<2,1>,<3,2>,<1,3>,<5,3>,<1,5>,<2,4>,<1,6>}，则出度最大的点是（）",
        "listData": [
            {
                "index": "A",
                "text": "6"
            },
            {
                "index": "B",
                "text": "4"
            },
            {
                "index": "C",
                "text": "3"
            },
            {
                "index": "D",
                "text": "1"
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "index": "16",
        "title": "已知有向图G=(V,E)，其中V={a,b,c,d,e}， E={,,,,,}，从a出发，字母小的顶点优先，则广度优先搜索的序列是（）",
        "listData": [
            {
                "index": "A",
                "text": "a e c d b"
            },
            {
                "index": "B",
                "text": "a b d c e"
            },
            {
                "index": "C",
                "text": "a d e c b"
            },
            {
                "index": "D",
                "text": "a b c d e"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "17",
        "title": "已知数据序列为33、66、22、44，把该序列依次插入到初始为空的二叉排序树中。现插入新数据35，它将是（）",
        "listData": [
            {
                "index": "A",
                "text": "22的右孩子"
            },
            {
                "index": "B",
                "text": "33的右孩子"
            },
            {
                "index": "C",
                "text": "44的左孩子"
            },
            {
                "index": "D",
                "text": "66的左孩子"
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "index": "18",
        "title": "以下属于哈希冲突处理方法的是（）",
        "listData": [
            {
                "index": "A",
                "text": "直接定址法"
            },
            {
                "index": "B",
                "text": "再哈希法"
            },
            {
                "index": "C",
                "text": "平衡二叉树"
            },
            {
                "index": "D",
                "text": "平方取中"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "index": "19",
        "title": "以下排序算法时间复杂度最小的是（）",
        "listData": [
            {
                "index": "A",
                "text": "冒泡排序"
            },
            {
                "index": "B",
                "text": "直接插入排序"
            },
            {
                "index": "C",
                "text": "简单选择排序"
            },
            {
                "index": "D",
                "text": "堆排序"
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "index": "20",
        "title": "现有100万个数据，需要找出最大的前10个数据，最快的算法是（）",
        "listData": [
            {
                "index": "A",
                "text": "快速排序"
            },
            {
                "index": "B",
                "text": "归并排序"
            },
            {
                "index": "C",
                "text": "简单选择排序"
            },
            {
                "index": "D",
                "text": "希尔排序"
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "index": "21",
        "title": "时间复杂度小于n平方的排序算法是（）",
        "listData": [
            {
                "index": "A",
                "text": "冒泡排序"
            },
            {
                "index": "B",
                "text": "快速排序"
            },
            {
                "index": "C",
                "text": "简单选择排序"
            },
            {
                "index": "D",
                "text": "直接插入排序"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "index": "22",
        "title": "序列19 11 23 14 55 68，采用希尔排序gap为n/2，则第一趟排序（）",
        "listData": [
            {
                "index": "A",
                "text": "14 19 11 55 23 68"
            },
            {
                "index": "B",
                "text": "19 23 11 14 55 68"
            },
            {
                "index": "C",
                "text": "11 14 19 23 55 68"
            },
            {
                "index": "D",
                "text": "14 19 11 55 33 68"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "index": "23",
        "title": "以下结构不是存储结构的（）",
        "listData": [
            {
                "index": "A",
                "text": "邻接表"
            },
            {
                "index": "B",
                "text": "逆邻接表"
            },
            {
                "index": "C",
                "text": "邻接矩阵"
            },
            {
                "index": "D",
                "text": "有向无环图"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "index": "24",
        "title": "以下算法中，用于求解两点最短路径的算法是（）",
        "listData": [
            {
                "index": "A",
                "text": "克鲁斯卡尔"
            },
            {
                "index": "B",
                "text": "迪杰斯特拉"
            },
            {
                "index": "C",
                "text": "普里姆"
            },
            {
                "index": "D",
                "text": "深度优先搜索"
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "index": "25",
        "title": "已知有向图G=(V,E)，其中V={1,2,3,4,5,6,}， E={<2,1>,<3,2>,<1,3>,<5,3>,<1,5>,<2,4>,<1,6>}，则出度最大的点是（）",
        "listData": [
            {
                "index": "A",
                "text": "6"
            },
            {
                "index": "B",
                "text": "4"
            },
            {
                "index": "C",
                "text": "3"
            },
            {
                "index": "D",
                "text": "1"
            }
        ],
        "answer": [
            "D"
        ]
    }
]